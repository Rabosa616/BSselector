# VCS branching strategy & workflow selector


objective
=========

The goal of this work is to provide ERNI project managers & integrators an easy way to select the *branching strategy* for their **new project**.

This work also expects to provide a distilled explanation of what a _branching strategy_ is and a selection of possible ones, as well as more in-depth documentation and references to detailed documentation.

However, the most valuable assert of this work is to provide a no-brainer way to decide which branching strategy to use, even for people who are not familiar with them, thanks to a selection system.

Attachments to this work are a set of slides and a document with examples of use, templates for workflow policies and rules (besides the branching strategy), and tips to select other fundamental things such as the merge or rebase policy, picking of automating versioning tools, code review strategy, VCS (git/svn), VCS wrapper (TFS), and whether to appoint or not an integrator.


purpose & value
===============

You may be wondering what a _branching strategy_ is and why do you need one for your project, specially if you haven't used one ever. Or if you haven't noticed.

Both concepts are all about working conventions (rules) between developers (humans). More specifically, in the way to use their VCSs. It is important that developers to agree, establish and abide on _how to_ do things when *storing*, *sharing*, *branching*, *merging*, and *publishing* the code they are working on. Therefore they will have to perform some ceremonies and follow some agreed rules.  

A _git workflow_ includes a branching strategy, but it's more than that, it defines more things.

It is important that the team agree in the selection, to avoid that it brings in the amount of rules that suits the project characteristics and the people preferences. It should neither be too many or too little complications nor should not fit the project.

After reading this, you may still be asking yourself questions such as "Do I really need one? I think I can do without, as I have always done".

The answer to this question is that _maybe yes, probably not_. And this, provided that everybody in your team masters git's intermediate usage (this includes _git rebase_).


why and how to use this work
----------------------------

This work is nothing more than a compilation of texts found on internet articles. Some of them are a kind of a reference, some others have been found by googling and the author has found them sound and interesting.

Reading this work, or at least the introduction and an overview should take less than half an hour. After that, and by identifying your project features as listed in section _selection parameters_ you should be able to get a very-good enough *curated choice* in less than 5 minutes.

Otherwise you may want to read some of the documents listed in the _annotated bibliography_ section, which would take more than 2 days.



benefits
--------

The benefits of having a (proper) workflow and branching strategy can be summarized as:

- all developers *do things* the same way
- avoid inconsistent practices and ill-defined workflows
- having a clean & sound log history
- not having an spaghetti-like log history (avoid history chaos)
- reduce time when sharing / branching / merging / publishing your code

It is estimated that not having a proper branching strategy or workflow may cost between 20%-40% of developer time.

Choosing a bad branching strategy will have the worse of both worlds: Your git history may perhaps still feel like chaos, but this time _actually wasting time_ on it (disturbing instead of helping).

You should not panic about not choosing the very best one, a few ones may suit you. You should panic about choosing one that **does not suit you**.


cost
----

Branching strategies may also have an impact in cost, specially the most complex ones. If done properly, with a good training and after an initial phase, this overhead shall not be too much.

It may be required to have a project integrator that is aware of all the branching and merging and that manages the releases.




what to choose & how
====================

What workflows and strategies can we choose from? With which criteria?

In the next section we will see which criteria (selection parameters) can be applied when choosing a git workflow and a branching strategy.



selection parameters
--------------------

The inputs, or selection parameters, that may be used in order to choose the branching strategy are:

* expected (main) project duration
* deployment frequency
* number of long-lived branches (1 or 2)
* number of total developers
* number of teams
* number of projects
* existing code base size (0?)
* existing code repos
* single version / different-custom products or different customers
* CI/CD: integration strategy(ies)
* CI/CD: deployment strategy(ies)
* error tolerance in production (none, trivial, serious)
* releasing strategy(ies)
* testing strategy / testing coverage
* team collaboration style
* application type (FW, app, web, ...)
* team working mode (in person/remote, full/part time)
* overall team experience with VCS tool
* personal habits (and prejudices)
* corporate policies (and managers/"gurus" prejudices)

They are listed in a somehow most to less relevant order.

For selecting a branching strategy, not all the combinations between all of them will be generated, only the most important ones. The other will be used as guides.


branching strategies
--------------------

The main output for this work is a chosen branching strategy. It can be any of:

- none (anarchy)
- simple-man workflow
- git-flow (the most complete one)
- github-flow
- gitlab-flow
- one-flow
- trunk-based development
- continuous integration (not in the CI-CD meaning)
- simplified git-flow
- centralized workflow
- one-flow plus
- forking workflow (as suggested by atlassian doc)
- ...

Remember, it is not fundamental to choose the very best strategy. Some of them are similar, and you may always change. The most important thing is that you DON'T pick the one that **DOES NOT suit you**.



other 'stuff'
-------------

The branching strategy is the most important thing of a (git) workflow. But a workflow also includes any amount of these other things:

* provide knowledge and references about branching strategies and related stuff
* define (document) workflow policies (issue handling, branch naming, etc)
* when to merge or rebase (for cases not defined by the branching strategy)
* when & where to squash (or not) - to have meaningful commits
* selection (or not) of an automatic versioning tool such as gitversion
* selection of the VCS (git is recommended, svn not discarded, hg... we don't know)
* have a wrapper layer over the VCS (i.e. TFS over git)
* code review method (pull request?)
* appointment (or not) of an integrator (release / branching manager)
* commit message style and content
* ...

You do not need to implement or choose something for any of these other items. Do what it is more convenient for you and your project.

Most of these other items are independent of the branching strategy, and a given set may fit many of them.



use of git vs svn vs others
---------------------------

This work is basically intended for use with projects that use git, and git is somehow the only VCS mentioned on it. However, this does not mean it should not be considered for projects that use subversion of other serious VCSs such as mercurial. Nor that other VCSs other than git should be discarded!

With subversion centralized use, and also because of its poor merging capabilities, merging happens much less often and usually with a lot of ceremony before. It is (almost) always easy to follow a subversion history timeline, and also to find changes.

It is also possible to apply most of these git workflows and branching strategies with subversion, so reading this document will be helpful in that case too.

Instead, because of git good design and powerful merging features, it is very easy to get into a messy, hard or impossible to follow history. More like a maze of a dish of long spaghetti.





concepts & definitions
======================

To start with, let's define some concepts that are fundamental to understand branching strategies. Some of these concepts are quite basic and well-known, other are less known and more advanced.


commit
------

Most developers know (or think they know) what a commit is, and what it implies.

It's one of the few commands shared by git, svn and mercurial (the big 3), also TFS and other wrappers.

But it does not do exactly the same on all.

* saves your changes
* publishes it (or not)

In subversion, it sends your changes to the server, and they become published. This may be desirable or not.

See article "Commit Often, Perfect Later, Publish Once" by Seth Robertson.



repository & working copy
-------------------------

This depends on the VCS.

In subversion, there is a clear separation between the central repository and the user working copy.

In git, a working copy is also a repository. But not always the other way around.



a branch
--------

It depends on the VCS used.

(elaborate/copy from MF)


Few people know or are aware of this: every single working copy (either a _git clone_ or _svn checkout_) is actually a branch. Because when you _svn update_ you may have unwanted merge conflicts.


branching is easy, merging is hard
----------------------------------

This happens daily in some teams: more than 1 developer modify the code, and the latest one has to solve the merge conflicts. That can be complicated and dangerous.

Modern VCS make it easy to branch, but then bringing the changes together may be painful, not only for the tools and their mechanics, but also because it is necessary to apply human and project knowledge to fix them. Sometimes it is not even possible.

Having a sound branching strategy will minimize these issues.



merging (reintegrating)
-----------------------

Perhaps, it can be stated that git was created because subversion merging design was flawed. At the time, other better VCSs were propietary and expensive.

In subversion, branches can not be merged - only commits can be merged into a branch. However it is possible to do some workarounds that were added to subversion




pull-request
------------

A pull-request is a merge (or rebase) filtered by an approval-system, named after the _git-pull_ command (git fetch + merge).

Its internals are hidden in the supposedly helping interfaces of several tools, such as github, TFS ... and most users don't actually know what they are doing.



merging conflicts
-----------------

Merging conflicts are the major pain when integrating branches that have diverged. Developers fear them. They may consume many hours, and also introduce functional errors when merging two branches that work fine.

Choosing a proper branching strategy is key to reduce the complexity of these merging conflicts.


rebase
------

In my limited experience, very few git users know well all the features of the rebase command.

It is also possible to rebase in subversion, with some workaround.



change frequency
----------------

One of the parameters for selecting a branching the branching strategy is the _change frequency_. This means how often developers commit/push changes.

This frequency is key in order to minimize merging conflicts.

* low frequency
* high frequency
* ...

However, this frequency can always considered relative. Relative with time, and relative to an specific area of the code. It also depends on the project maturity. The more lines of code, the less likely are merging conflicts, and the important of change frequency decreases.


git usage
---------

In the author's experience, and deep and sincere apologies come with this statement if it's not your case, very few people know how to properly use git at its most basic commands beyond (or including) commit: fetch, pull, merge and push.

Also, most people follow a very simple git workflow, either with command line or a graphic tool, or with a wrapper such as Microsoft's TFS.


deployment strategies
---------------------

First 2 for FW/user applications. The other 6 for services.

* user notification / pull
* automated upgrade system
* bluegreen deployment : Version B is released alongside version A, then the traffic is switched to version B.
* canary : Version B is released to a subset of users, then proceed to a full rollout. Low testing confidence.
* A/B testing: Version B is released to a subset of users under specific condition.
* Recreate: Version A is terminated then version B is rolled out, implies shutdown time.
* Ramped (also known as rolling-update or incremental): Version B is slowly rolled out and replacing version A.
* Shadow: Version B receives real-world traffic alongside version A and doesn't impact the response.


types of branches
-----------------

* release branch
* maturity branch
* long-lived release branch
* environment branch
* hotfix branch
* experimental branch
* future branch
* collaboration branch
* team-integration branch


deployment / release strategies
-------------------------------

* release train (periodic releases)
* release-ready mainline



flexible branching strategy
---------------------------

True champions of VCSs and their branching strategies may consider switching it in the different maturity phases of a (years-long) project.

May start with the continuous integration branching strategy until the first prototype is ready (version 0.1), then go with git-flow.




branching strategies list
=========================


NONE (simplest - non-existing, anarchy)
---------------------------------------

No workflow rules are defined. May be ok, but may also be a mess. Low ceremony anyhow. Perhaps useful for teams with 3 or less people.



git-flow
--------

Complex, suitable for large and long-lived projects, with different releases, products, ...

Has 2 stable and long-lived branches:

* master: for publishing
* develop: for integrating all the development before publishing


gitlab-flow
-----------

Simpler than git-flow, more complex than github-flow (really?)

It has 11 rules, not only related to the VCS, but also to testing and deployment.

Has intermediate branches such as production and staging.

Emphasizes testing before testing, cant merge if tests are not passed.

Emphasis on CI-CD (promotes automatic deployment)



github-flow
-----------

Much simpler than git-flow and gitlab-flow.

One stable branch (master), where everything is (supposed to be) deployable, therefore supposed to be good for continuous deployment.

Create feature branches, and commit and also push to the server.

Do pull-requests when the feature is ready.



one-flow
--------

One stable branch (master). All new changes/features are rebased to the latest stable/published release.

Allows feature branches, hotfix branches and also release branches.

Its author claims that it is much simpler but also equally powerful as git-flow.

Not recommended for continuous deployment.


simplified git-flow
-------------------

A subset of git-flow.


continuous-integration (not as in CI-CD!)
-----------------------------------------

Tries to emulate that everybody works on the same files/folders/disk.

The main purpose (besides sharing continuously) is to minimize merging conflicts.

Developers must commit at least once a day and share their healthy work.

Not valid for multiple product development.


trunk-based development
-----------------------

Similar to continuous integration, but allows short-lived feature branches. Has also release branches, where it is forbidden to commit.

Supposed to enable CI-CD (continuous integration and deployment).

Not valid for large number of developers and several parallel developments.


subversion-like development
---------------------------

The subversion VCS has a very limited merging capability, by poor design. It suggests creating branches/releases/tags folders.

Therefore it encourages creating all branches under the branches folder, releases under the releases folder, etc. Still it allows for many flexibility which can lead to chaos without a proper branching strategy or workflow guidelines.



the HP (BCN) way
----------------

A use case of the subversion-like development is the one used by the author at his current customer, HP. It uses subversion with some enhancements.

It's a bit like git-flow without a develop branch => trunk is expected to be always clean and pure (neither build errors nor failing tests), but this is not always the case because of the many diverse products.

release (stabilization) branches and general-purpose branches leave from trunk

feature branches are called tasks, and leave from trunk or any other branch

no branch can have the same name of any other branch, even if they are completely unrelated, because of the upper layer of services




Marc-flow (at HP)
-----------------

What is Marc doing?

something similar to one-flow (always rebasing from latest)




branching strategies types
==========================


complex
-------

* git-flow
* none (anarchy)
* gitlab-flow (sometimes)


feature-driven
--------------

* gitlab-flow
* one-flow


continuous delivery oriented
-------------------

* github-flow
* gitlab-flow
* continuous integration
* trunk-based development


maintain several products/releases/customers
--------------------------------------------

* git-flow



maintain only 1 product
-----------------------

* one-flow
* gitlab-flow
* gitlab-flow


low test coverage
-----------------

* git-flow
* gitlab-flow


high test coverage
------------------

* github-flow


1 developer
-----------

* none (anarchy)
* all the others ...


1-3 developers
--------------

* all of them

3-8 developers
--------------

* github-flow
* one-flow

1-8+ developers
---------------

* github-flow
* one-flow




more classifications are possible!
----------------------------------

add one classification for each selection parameter


choose yours
============


TODO: use Alberto's template

Git-flow

* Works well if:
  - Long Project duration
  - 8+ developers
  - 2 to n teams
  - 2 to n projects
  - New codebase
  - Maintain several products/releases/customers
  - Low test coverage
  - Good error tolerance in production
* Doesn't work well if:
  - CD release strategy
  - Web applications
  - Big testing strategy
  - ...


misc
====

This work is *not limited* to existing bibliography: Also provides concepts and ideas based on both the author and supervisor experience.


have a chapter about _change frequency_, which is the most important quantitative metric
https://martinfowler.com/bliki/FrequencyReducesDifficulty.html

MF: high-frequency / low-frequency:

- https://martinfowler.com/articles/branching-patterns.html#integration-frequency
- https://martinfowler.com/articles/branching-patterns.html#Low-frequencyIntegration
- https://martinfowler.com/articles/branching-patterns.html#High-frequencyIntegration
- https://martinfowler.com/articles/branching-patterns.html#compare-freq

i don't like this approach, prefer using:

_conflict probability_ concept: depending of change frequency and developers working in the same area

_semantic conflict_ concept : serious conflicts that may happen during refactoring and may go unnoticed

_P2PC_ : (mine) person to person communication, the best and cheapest way to avoid semantic conflicts (agile's stand-up/daily meetings)

be flexible and agile: need not sticking with the same branching strategy *always* and *everywhere*
provide the _erni_
